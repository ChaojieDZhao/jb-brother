---
title: oracle物化视图的使用
date: 2016-11-20 09:09:38
tags:
- view
---


### 物化视图的类型：

on demand、on commit 二者的区别在于刷新方法的不同
on demand顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(refresh)，即更新物化视图，以保证和基表数据的一致性；
而on commit是说，一旦基表有了commit，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。

### on demand物化视图 
物化视图的创建本身是很复杂和需要优化参数设置的，特别是针对大型生产数据库系统而言。
但oracle允许以这种最简单的，类似于普通视图的方式来做，所以不可避免的会涉及到默认值问题。
也就是说oracle给物化视图的重要定义参数的默认值处理是我们需要特别注意的。

物化视图的特点：
(1) 物化视图在某种意义上说就是一个物理表(而且不仅仅是一个物理表)，这通过其可以被user_tables查询出来，而得到佐证； 
(2) 物化视图也是一种段(segment)，所以其有自己的物理存储属性； 
(3) 物化视图会占用数据库磁盘空间，这点从user_segment的查询结果，可以得到佐证； 
创建语句：create materialized view mv_name as select * from table_name 
默认情况下，如果没指定刷新方法和刷新模式，则oracle默认为force和demand。

### on commit物化视图
on commit物化视图的创建，和上面创建on demand的物化视图区别不大。因为on demand是默认的，所以on commit物化视图，需要再增加个参数即可。
需要注意的是，无法在定义时仅指定on commit，还得附带个参数才行。 
创建on commit物化视图：create materialized view mv_name refresh force on commit as select * from table_name  

### 物化视图的刷新
刷新（refresh）：指当基表发生了dml操作后，物化视图何时采用哪种方式和基表进行同步。
刷新的模式有两种：on demand和on commit。（如上所述） 
刷新的方法有四种：fast、complete、force和never。
fast刷新采用增量刷新，只刷新自上次刷新以后进行的修改。
complete刷新对整个物化视图进行完全的刷新。
如果选择force方式，则oracle在刷新时会去判断是否可以进行快速刷新，如果可以则采用fast方式，否则采用complete的方式。
never指物化视图不进行任何刷新。
对于已经创建好的物化视图，可以修改其刷新方式，比如把物化视图mv_name的刷新方式修改为每天晚上10点刷新一次：
``` sql
alter materialized view mv_name refresh force on demand start with sysdate next to_date(concat(to_char(sysdate+1,'dd-mm-yyyy'),' 22:00:00'),'dd-mm-yyyy hh24:mi:ss')
-或者job使用存储过程当时刷新，两者相差无几。先创建存储过程
create or replace procedure p_refresh_stats is
begin
  dbms_mview.refresh('mv_name', 'c');
end p_refresh_stats;
-然后创建job执行该存储过程
begin
  sys.dbms_scheduler.create_job(job_name            => 'bjd_branch.job_refresh_stats',
                                job_type            => 'stored_procedure',
                                job_action          => 'p_refresh_stats',
                                start_date          => to_date('01-07-2016 00:00:00', 'dd-mm-yyyy hh24:mi:ss'),
                                repeat_interval     => 'freq=hourly;interval=1',
                                end_date            => to_date('01-07-2022 00:00:00', 'dd-mm-yyyy hh24:mi:ss'),
                                job_class           => 'default_job_class',
                                enabled             => true,
                                auto_drop           => false,
                                comments            => '');
end;
```

### 物化视图具有表一样的特征

所以可以像对表一样，我们可以为它创建索引，创建方法和对表一样。

### 物化视图的删除
虽然物化视图是和表一起管理的，但是在经常使用的oplsql工具中，并不能用删除表的方式来删除
（在表上右键选择‘drop’并不能删除物化视图），可以使用语句来实现：drop materialized view mv_name

 

### 普通视图和物化视图的区别
普通视图和物化视图根本就不是一个东西，说区别都是硬拼到一起的，
首先明白基本概念，普通视图是不存储任何数据的，他只有定义，在查询中是转换为对应的定义sql去查询，
而物化视图是将数据转换为一个表，实际存储着数据，这样查询数据，就不用关联一大堆表，如果表很大的话，会在临时表空间内做大量的操作。

普通视图的三个特征：
1、是简化设计，清晰编码的东西，他并不是提高性能的，他的存在只会降低性能
（如一个视图7个表关联，另一个视图8个表，程序员不知道，觉得很方便，把两个视图关联再做一个视图，那就惨了），他的存在未了在设计上的方便性

2、其次，是安全，在授权给其他用户或者查看角度，多个表关联只允许查看，不允许修改，
单表也可以同with read only来控制，当然有些项目基于视图做面向对象的开发，即在视图上去做instand of触发器，就我个人而言是不站同的，虽然开发上方便，但是未必是好事。

3、从不同的角度看不同的维度，视图可以划分维度和权限，并使多个维度的综合，也就是你要什么就可以从不同的角度看，而表是一个实体的而已，
一般维度较少（如：人员表和身份表关联，从人员表可以查看人员的维度统计，从身份看，可以看不同种类的身份有那些人或者多少人），
其次另一个如系统视图user_table、tab、user_objects这些视图，不同的用户下看到的肯定是不一样的，看的是自己的东西。
物化视图呢，用于olap系统中，当然部分oltp系统的小部分功能未了提高性能会借鉴一点点，因为表关联的开销很大，所以在开发中很多人就像把这个代价交给定期转存来完成，
oracle当然也提供了这个功能，就是将视图（或者一个大sql）的信息转换为物理数据存储，然后提供不同的策略：
定时刷还是及时刷、增量刷还是全局刷等等可以根据实际情况进行选择，总之你差的是表，不是视图。


关于在刷新和索引上的区别
他们两个没有联系吧，刷新我不清楚你是否指的是物化视图的刷新，因为刷新的概念很泛，你说到这里我就理解为物化视图的刷新了，
上面也已经说了，这是一种策略和方法，其实它是通过对视图关联表上创建相应的log，根据日志信息的sql同步到物化视图中的，
一般来说：定时的一般是全局刷，及时的一般是局部刷。

而索引这个说起来就多了，可以说索引专门是一门课程，大概点来说，索引一般有普通索引、位图索引、唯一性索引（还有全文索引啥的，一般不用），
其实仔细研究会发现无论是那一种索引都是b+树为基础，并起存放方式和表一样，是以段为单位，只是内部有树关系而已。

1、普通索引是根据b+树找到第一个（索引时有序的），然后以当前为基准，向后顺序找到不符合条件的健值为止。
2、位图是在叶子节点上根据位图种类对叶子节点的值进行01编码存放（如该字段有1、2、3三种值，就会在叶子节点上有三个位图，
每个位图根据健值和rowid顺序存放是否为1、是否为2、是否为3，所以在rbo下统计很快，cbo下一般会认为是普通索引）。

3、也是按照b+树找，只是找到就不再做任何操作，因为是唯一的。
因为b+查找是一个类似表的查询，而且获取到rowid后还是要回表查询的，所以这个过程的开销要和全表扫描计算那个结果更加快，oracle才会选择是走索引还是走全表扫描，
当然对于cbo和rbo选择的方式不一样，具体又是很多，cbo要依赖于表的统计信息，rbo是依赖于尝试。