---
title: spring中的事物控制
date: 2016-05-30 15:50:53
tags:
- transaction
---

## 数据库事务中的ACID
**原子性（Atomicity）**
要么做完，要么就不做。如果在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

**一致性（Consistency）**
一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。
如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。

**隔离性（Isolation）**
隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。

**持久性（Durability）**
在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

{% centerquote %}原子性是基础，隔离性是手段，持久性是目的，真正的老大就是一致性{% endcenterquote %}

## 事务隔离级别（Transaction Isolation Level）
> READ\_UNCOMMITTED
> READ\_COMMITTED
> REPEATABLE\_READ
> SERIALIZABLE

## 数据库的一般性事务问题
> Dirty Read（脏读） （针对未提交数据）如果一个事务中对数据进行了更新，但事务还没有提交，
另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据。

> Unrepeatable Read（不可重复读） 不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务1在事务2的更新操作之前读取一次数据，
在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的，所以，Read Uncommitted也无法避免不可重复读取的问题。

> Phantom Read（幻影读） 幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在Read Uncommitted隔离级别下， 
不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的，所以，Read Uncommitted同样无法避免幻读的问题。

## 事物问题和隔离级别之间的关系

| 事务隔离级别  |脏读 |  不可重复读  |幻影读
| --------- | :----: | :----: |  :----: |
|READ_UNCOMMITTED| 允许|允许|允许|
|READ_COMMITTED| 禁止|允许|允许|
|REPEATABLE_READ|禁止|禁止|允许|
|SERIALIZABLE|禁止|禁止|禁止|

一个不错的demo地址：  [spring-boot-sample-transaction](https://gitee.com/Zalldios/spring-bucket-demo/tree/master/spring-bucket/spring-boot)