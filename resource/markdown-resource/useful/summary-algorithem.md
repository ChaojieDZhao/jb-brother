## 排序算法
### Bubble Sort（冒泡排序）
> 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。
这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
[](../../jb-app/jb-algorithem/src/main/java/algorithem/problem74/BubbleSort.java)

### Insertion Sort（插入排序）
> 适用于小型数据结构和排序完整度比较高的数据结构，插入排序把数据分为了两个区间，一个是已排序，一个是未排序，每遍历一个未排序区间数据，则插入到已排序区间结构。
直到未排序区间为空为止。
[](../../jb-app/jb-algorithem/src/main/java/algorithem/problem76/InsertionSort.java)

### Selection Sort（选择排序）
> 和插入排序有点类似，就是在未排序的区间内找到最大或者最小的值，添加到已排序区间的最末。
[](../../jb-app/jb-algorithem/src/main/java/algorithem/problem75/SelectionSort.java)

### Quick Sort（快速排序）
> 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

## Divide and Conquer(分治法)
- 1 分--将问题分解为规模更小的子问题； 
- 2 治--将这些规模更小的子问题逐个击破；     
- 3 合--将已解决的子问题合并，最终得出“母”问题的解； 

## recursive
>  栈维护了每个函数调用的信息直到函数返回后才释放，这需要占用相当大的空间，尤其是在程序中使用了许多的递归调用的情况下。
除此之外，因为有大量的信息需要保存和恢复，因此生成和销毁活跃记录需要消耗一定的时间。我们需要考虑采用迭代的方案。
简而言之，递归的压栈和出栈，时间和空间都有很大的消耗，

## Tail recursive approach
> 在普通递归中，我们先调用递归函数，待函数返回并从中获得部分结果后再往下处理。在这种情况下，程序的最终结果要在所有函数调用均逐一返回后才能得到。
而在尾递归中，当前的这次调用先计算出程序的部分结果，在下一次递归调用时将该结果作为参数传递，那么到了最后一次调用，程序的最终结果就能得到。

> 如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。
当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。
尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。

> 当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。
编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。
通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。
[](../../../jb-app/jb-algorithem/src/main/java/algorithem/problem9/Factorial.java)

### binary search
> 二分搜索

### PreOrder
> 前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树

### Inorder
> 中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回。
- 1 中序遍历左子树
- 2 访问根结点
- 3 中序遍历右子树

### PostOrder
> 后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。
- 1 后序遍历左子树
- 2 后序遍历右子树
- 3 访问根结点

### 巧用数组下标
> 给你n个无序的int整型数组arr，并且这些整数的取值范围都在0-20之间，要你在 O(n) 的时间复杂度中把这 n 个数按照从小到大的顺序打印出来。
```java_holder_method_tree
public void f(int arr[]) {
       int[] temp = new int[21];    //初始化的时候大家的次数都为0
       for (int i = 0; i < arr.length; i++) {
           temp[arr[i]]++;    //如果有arr[]里面有9，则代表temp下标为9的元素加一了。
       }
       //顺序打印
       for (int i = 0; i < 21; i++) { 
           for (int j = 0; j < temp[i]; j++) {
               System.out.println(i);
           }
       }
   }
```

### 巧用区域
> 遍历数组的时候进行越界判断，如果下标越界了，就把他至为0重新遍历，特别是在环形数组里面。
pos = (pos+1) /n    
arrays[pos]    

### 最小堆排序算法（TopK问题是指从大量数据（源数据）中获取最大（或最小）的K个数据）
> 最小堆（小根堆）是一种数据结构，它首先是一颗完全二叉树，并且，它所有父节点的值小于或等于两个子节点的值。
最小堆的存储结构（物理结构）实际上是一个数组。




















