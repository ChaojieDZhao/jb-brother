**对于HTTP**，根据OSI七层模型，它位于顶层应用层（第七层）。底层使用了网络层(第三层，操作IP地址)的IP协议（路由寻址），
传输层（第四层）使用了TCP，靠TCP的三次握手，四次挥手建立和断开连接，所以HTTP的长短连接就是TCP的长短连接。

连接个数：多连接
连接方式：短连接
传输方式：同步传输
传输协议：HTTP
序列化方式：表单序列化（JSON，这种序列化方式还需要转成byte数组才可以在网络中传输）
适用范围：传入传出数据包大小混合，可以通过URL访问，可以在浏览器访问的请求。

**对于Dubbo协议**，是用单一长连接，2以上版本默认Dubbo协议，以下为缺省配置：

传输方法：异步的NIO（NON BLOCKING IO，和BIO比，BIO每个请求要有一个线程处理，服务端线程数有限，未分到处理线程的请求会被阻塞等待。NIO可以用单线程监听多个CHANNEL上的IO事件，连接的socket里只有真正发出IO请求时才会获得线程来处理，IO部分是同步的，减少了BIO中的等待时间），基于Netty（1版本用Mina，Netty靠future-listener机制实现异步的NIO）,负责Socket部分网络传输。
序列化：Hessian
传输协议：TCP
连接数量：单连接（一个consumer和一个provider组成一个套接字，每条消息都有一个消息id，如果使用多线程调用一个consumer，也可以进行根据id区分）
连接方式：长连接（通过定时心跳来维持长连接）

Dubbo也可配置rmi(java标准rpc,remote接口),thrift,Hessian,HTTP等其他协议，基本都是多个短连接的，有别的使用场景。

**dubbo协议异步单一长连接的意义**

单连接，确保了一个消费者和提供者只有一个连接，避免了单一消费者多连接增加提供者压力的风险。且大多数下游服务都是公有，一个服务会有大量的消费者。
长连接，TCP面向连接，要三次挥手，四次挥手，减少了这部分建立断开的消耗。
异步：因为大多情况下还是消费者数量大于提供者，异步传输方式有效减少了提供者的压力。

适合dubbo的场景：
consumer数量要大于provider数量，因为单一长连接，需要大量消费者来增加连接数量以用满网卡。
适用于后端上游服务（例如和前端交互的controller，数量会很多）调用一些公有下游服务（公有功能服务，例如公有数据出口，清算结算服务，需要被许多上游服务调用）。
provider的服务有大量consumer，可以是高并发的。

不适合做上传下载等数据包很大的功能，因为是单连接，需要避免网络瓶颈。

## 为什么hissian序列化快

因为它是二进制通信协议，可以直接在网络中传输。
二是hissian对对象的转化进行了优化。
没有额外不加信息，比如json序列化连有`{,}`这些字符。所以数据量更大。

## 序列化

把对象转换为字节序列的过程称为对象的序列化
把字节序列恢复为对象的过程称为对象的反序列化

用途：
把对象的字节序列永久保存到硬盘上，通常存放在一个文件中
将对象转换为字节序列在网络上便于传输（分布式系统中应用较广）

## 序列化里的类型信息

序列化就是把对象转换为二进制数据，反序列化就把二进制数据转换为对象。
各种序列化库层出不穷，其中有一个重要的区别：类型信息存放在哪？

可以分为三种：
1、不保存类型信息
典型的是各种json序列化库，优点是灵活，缺点是使用的双方都要知道类型是什么。当然有一些json库会提供一些扩展，偷偷把类型信息插入到json里。

2、类型信息保存到序列化结果里
比如java自带的序列化，hessian等。缺点是类型信息冗余。比如RPC里每一个request都要带上类型。因此有一种常见的RPC优化手段就是两端协商之后，后续的请求不需要再带上类型信息。

3、在生成代码里带上类型信息
通常是在IDL文件里写好package和类名，生成的代码直接就有了类型信息。比如protobuf, thrift。缺点是需要生成代码，双方都要知道IDL文件。
