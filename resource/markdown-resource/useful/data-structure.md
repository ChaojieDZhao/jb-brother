# 数据结构

## 数据的逻辑结构：
> - 集合结构
> - 线性结构
> - 树结构
> - 图结构或者网状结构

##  数据的存储结构
> - 顺序存储结构
> - 链式存储结构
> - 图结构或者网状结构

##  算法的五个定义
> - 有穷性
> - 确定性
> - 可行性
> - 输入
> - 输出

##  评价算法的三个定义
> - 正确性
> - 可读性
> - 健壮性
> - 高效性

## 算法的时间复杂度和空间复杂度
一个语句执行的重复执行次数称为语句的频度，一个算法的时间复杂度是该算法的执行时间，即为T(n)
```  c++
for(i=1;i<=n;i++)               //频度为n+1
  for(j=1;j<=i;j++)            //频度为n*(n+1)
  {c[i][j] = 0;       //频度为n^2
     for(k=1;k<=n;k++)    //频度为n^2*(n+1)
     c[i][j] = c[i][j]+a[i][k]*b[k][j]               //频度为n^3
  }
```
**不过人们最在乎的是平均执行时长和最大执行时长**

## 线性表和链表
线性表的特点是：逻辑上相邻的数据匀速，其物理次序也是相邻的。
线性表的时间复杂度为O(n)
> 比如for(int i =0;i <  seq.length;i++){
   if 相等 return;
}
频率是（n+1）/2

链表的特点是：用一组任意的存储单元存储线性表的数据元素（可以连续，也可以不连续），因此一定需要指针域和数据域。单链表只有头指针可以唯一确定。
链表的查找时间复杂度为O(n)

## 栈和队列
栈的应用举例，比如括号的匹配，运算符优先。

## 哈夫曼编码的应用
生成最段的报文，就是一次从叶子节点出发，向上回溯至根节点为止，回溯时走左分支则生成代码0，反之则生成1.

## 查询算法

###  线性查找和折半查找和二叉排序树查找和平衡二叉树查找（适合在计算机内存中比较小的文件，统称为内查找法）
> 折半查找又称为二分查找。（不过仅限于顺序存储结构和关键字有序排序，通知增删改的时候还需要维护，咋办查找的时间复杂度为LOG2N）
> 二叉树查找法是二分查找的进化，不满足二分查找条件的限制。

### AVL树
> 平衡二叉树的定义 （AVL—— 发明者为Adel'son-Vel'skii 和 Landis）
> 它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。 也就是说AVL树每个节点的平衡因子只可能是-1、0和1（左子树高度减去右子树高度）。
那么如何是二叉查找树在添加数据的同时保持平衡呢？基本思想就是：当在二叉排序树中插入一个节点时，首先检查是否因插入而破坏了平衡，若 破坏，则找出其中的最小不平衡二叉树，
在保持二叉排序树特性的情况下，调整最小不平衡子树中节点之间的关系，以达 到新的平衡。所谓最小不平衡子树 指离插入节点最近且以平衡因子的绝对值大于1的节点作为根的子树。 


### 红黑树(RBTREE，一种特殊的二叉查找树)
- 1. 每一个结点要么是红色，要么是黑色。
- 2. 根结点是黑色的。
- 3. 所有叶子结点都是黑色的（实际上都是Null指针，下图用NIL表示）。叶子结点不包含任何关键字信息，所有查询关键字都在非终结点上。
- 4. 每个红色结点的两个子节点必须是黑色的。换句话说：从每个叶子到根的所有路径上不能有两个连续的红色结点
- 5. 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点

#### 红黑树相关定理
- 1. 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。
根据上面的性质5我们知道上图的红黑树每条路径上都是3个黑结点。因此最短路径长度为2(没有红结点的路径)。再根据性质4(两个红结点不能相连)和性质1，2(叶子和根必须是黑结点)。
那么我们可以得出：一条具有3个黑结点的路径上最多只能有2个红结点(红黑间隔存在)。也就是说黑深度为2（根结点也是黑色）的红黑树最长路径为4，最短路径为2。
从这一点我们可以看出红黑树是 大致平衡的。 (当然比平衡二叉树要差一些，AVL的平衡因子最多为1)
- 2. 红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h<=2bd
根据定理1，我们不难说明这一点。bd是红黑树的最短路径长度。而可能的最长路径长度(树高的最大值)就是红黑相间的路径，等于2bd。因此h<=2bd。
- 3. 一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h<=2log(n+1)
下面我们首先证明一颗有n个内部结点的红黑树满足n>=2^bd-1。这可以用数学归纳法证明，施归纳于树高h。
当h=0时，这相当于是一个叶结点，黑高度bd为0，而内部结点数量n为0，此时0>=2^0-1成立。
假设树高h<=t时，n>=2^bd-1成立，我们记一颗树高 为t+1的红黑树的根结点的左子树的内部结点数量为nl，右子树的内部结点数量为nr，记这两颗子树的黑高度为bd'（注意这两颗子树的黑高度必然一 样），
显然这两颗子树的树高<=t，于是有nl>=2^bd'-1以及nr>=2^bd'-1，将这两个不等式相加有nl+nr>=2^(bd'+1)-2，将该不等式左右加1，
得到n>=2^(bd'+1)-1，很显然bd'+1>=bd，于是前面的不等式可以 变为n>=2^bd-1，这样就证明了一颗有n个内部结点的红黑树满足n>=2^bd-1。
在根据定理2，h<=2bd。即n>=2^(h/2)-1，那么h<=2log(n+1)
从这里我们能够看出，红黑树的查找长度最多不超过2log(n+1)，因此其查找时间复杂度也是O(log N)级别的。


###  平衡多叉树(B-和B+)

### 散列表的查找
> 前面的基于线性表和树表结构的查找方法都是以关键字的比较为基础的，在查找过程中只考虑各类元素关键字的相对大小，记录在存储结构中的位置和关键字无直接关系，其查找时间至于表的长度有关。
> 但是如果节点个数特别多的时候，查找就需要大量的与无效节点的关键字进行比较，导致查询速度很慢。
> 如果能在元素的的存储位置和其关键字之间建立某种关系，那么在进行查找的时候，就无需做很多次的比较，按照这种关系直接由关键字找到相应的记录，这就是三列查找法的思想。
- 散列函数和散列地址：在记录的存储位置p和其关键字key之间建立一个确定的对应关系，p=H(key);
- 散列表：一个连续的地址空间，用于存储按照散列函数计算得到的相应散列地址的数据记录。
- 冲突和同义词：不同的关键字得到同一个散列地址，现象称为冲突，关键字称为同义词。

### 散列表处理冲突的方法？
- 开发地址方法：把记录存储在散列表数组中，当某一个关键字key的初始散列地址h0=H(key)冲突时，采用合适的犯法计算得到另一个地址h1;
- 链地址方法：把所有具有相同散列地址的记录放在同一个单链表中，称为同义词链表。
