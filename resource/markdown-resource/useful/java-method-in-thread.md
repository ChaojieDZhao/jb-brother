---
title: "线程中相关的方法"
date: 2017-02-22 13:30:36
tags:
- java
---
## sleep()
> 使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。    
例如有两个线程同时执行(没有synchronized)一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有 Sleep()方法，只有高优先级的线程执行完毕后，低优先级的线程才能够执行；    
但是高优先级的线程sleep(500)后，低优先级就有机会执行了。    
总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。    

## join()
> t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程.    
如在t1线程中调用t2.join(),则需要t2线程执行完后t1方能继续执行。    

## yield()
> 该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield()方法只能让同优先级的线程有执行的机会。

## wait()和notify()、notifyAll()
> 这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用。
synchronized关键字用于保护共享数据，阻止其他线 程对共享数据的存取，但是这样程序的流程就很不灵活了，    
如何才能在当前线程还没退出synchronized数据块时让其他线程也有机会访问共享数据呢？ 此时就用这三个方法来灵活控制。    
wait()方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。
当调用notify()方法 后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则 notify()不起作用。
notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。    
**NOTE:这三个方法都是java.lang.Object的方法**      
**NOTE:sleep()方法会继续持有锁，wait()方法调用后会释放调锁资源**    


