NIO 2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。

异步的套接字通道是真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。
他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。

 AIO的API比NIO的使用起来简单的多，主要就是监听、读、写等各种CompletionHandler。
 
 
 
## 
> 在NIO中，当发生相应读写事件时，用户线程得到通知，表明数据已就绪，开始同步调用非阻塞读写函数
在AIO中，当发生相应事件时，用户线程得到通知，表明I/O操作已经由操作系统异步完成，用户线程只需事先向内核申明I/O缓冲区、注册handler并定义回调的completed方法即可

## AIO与NIO的区别，在Server端体现为Reactor/Proactor的区别，在NIO中，监控的事件通常为数据的到达；在AIO中，监控的是事件通常为I/O的完成
综上：
1、分类
所谓的blocking、non-blocking、asynchronous I/O，是针对用户程序而言的，用户程序根据场景选择使用对应的I/O API。
等待数据就绪（操作） 读写数据(操作完成) 
blocking模式   阻塞   阻塞
non-blocking模式   只阻塞select线程 数据已就绪，同步读取，无需阻塞等待 
asynchronous模式    发起操作(connect,read/write,bind等)     处理操作完成的通知，或通过Future<?>获取结果


2、non-blocking与async
2.1 两者相互协作。non-blocking模式下，多路复用调用select的线程是阻塞的，读写数据的线程是同步操作的，读写数据的线程与select线程之间，可看做异步的，select线程只捕捉事件并通知读写线程；
2.2 而asynchronous模式下，对于用户线程确实是无阻塞并且完全异步处理的，用户线程只需要发起操作，在需要关心的时候获取操作结果，或者操作有结果后通过
已注册的回调对象去处理。但是Future<?>.get() 是同步的调用，如果在发起操作的线程里调用，跟blocking模式效果几乎一样。因此asynchronous模式的handler
方式使用更频繁。


举另外个例子来更好地理解Reactor与Proactor两种模式的区别。这里我们只关注read操作，因为write操作也是差不多的。下面是Reactor的做法：

某个事件处理者宣称它对某个socket上的读事件很感兴趣;
事件分离者等着这个事件的发生;
当事件发生了，事件分离器被唤醒，这负责通知先前那个事件处理者;
事件处理者收到消息，于是去那个socket上读数据了。 如果需要，它再次宣称对这个socket上的读事件感兴趣，一直重复上面的步骤;
下面再来看看真正意义的异步模式Proactor是如何做的：

事件处理者直接投递发一个读操作(当然，操作系统必须支持这个异步操作)。 这个时候，事件处理者根本不关心读事件，它只管发这么个请求，它魂牵梦萦的是这个读操作的完成事件。这个处理者很拽，发个命令就不管具体的事情了，只等着别人（系统）帮他搞定的时候给他回个话。
事件分离者等着这个读事件的完成(比较下与Reactor的不同);
当事件分离者默默等待完成事情到来的同时，操作系统已经在一边开始干活了，它从目标读取数据，放入用户提供的缓存区中，最后通知事件分离者，这个事情我搞完了;
事件分享者通知之前的事件处理者: 你吩咐的事情搞定了;
事件处理者这时会发现想要读的数据已经乖乖地放在他提供的缓存区中，想怎么处理都行了。如果有需要，事件处理者还像之前一样发起另外一个写操作，和上面的几个步骤一样。